This is the grammar I'm using. In general capitalized words refer to nonterminal
symbols, all caps words are terminals with regular expressions, lower case words
are keywords, and symbols are literal. I use [.]+ and [.]* for lists to make
things a little simpler. Functions use semicolons to end lines so that we can
make whitespace unimportant. A function might look like

>>> foo :: Int -> Int -> Bool;
>>> foo 0 0 = false;
>>> foo 1 1 = true;
>>> foo a b = a < b;

Also note that comments are haskell style, i.e., they may be -- to \n or they
may be {* to *}. Functions are curried so function application always occurs
between exactly two expressions and should be left associative.

Program ::= [Declaration]+

Declaration ::= FunctionType
              | FunctionDef
              | Datatype

FunctionType ::= ID :: Type ;

Type ::= TYPE
       | ( )
       | [ Type ]
       | ( [Type ,]+ Type )
       | Type -> Type
       | ( Type )

FunctionDef ::= ID [PExpr]* = Expr ;

Datatype ::= data TYPE = [Constructor |]* Constructor

Constructor ::= TYPE [Type]*

Expr ::= ID                            -- Variable reference
       | INT                           -- Integer literal
       | STRING                        -- String literal
       | true                          -- Boolean literal true
       | false                         -- Boolean literal false
       | Expr + Expr                   -- Arithmetic Expressions
       | Expr - Expr                   --
       | Expr * Expr                   --
       | Expr / Expr                   --
       | ~ Expr                        -- Arithmetic negation
       | Expr < Expr                   -- Comparison operators
       | Expr == Expr                  --
       | Expr <= Expr                  --
       | Expr && Expr                  -- Boolean expressions
       | Expr || Expr                  --
       | not Expr                      --
       | Expr . Expr                   -- Composition
       | ( Expr )                      -- Grouping
       | ( Expr , [Expr ,]* Expr )     -- Tuple construction
       | ( )                           -- Unit value
       | Expr : Expr                   -- List construction
       | [ ]                           -- Empty list
       | let ID = Expr in Expr         --
       | case Expr of [CaseBranch ;]+  --
       | if Expr then Expr else Expr   --
       | Application                   -- Function application
       | TYPE [Expr]*                  -- Constructor

Application ::= AExpr
              | Application AExpr

AExpr ::= ID
        | INT
        | STRING
        | true
        | false
        | ( )
        | ( Expr )
        | ( [Expr ,]+ Expr )
        | [ ]

CaseBranch ::= PExpr -> Expr

PExpr ::= ID
        | INT
        | STRING
        | true
        | false
        | ( )
        | ( [PExpr ,]* PExpr )
        | [ ]
        | PExpr : PExpr
        | Type [PExpr]   -- Constructor matching


Regular expressions for terminals:
TYPE =~ [A-Z][A-Za-z0-9_]
ID =~ [a-z_][A-Za-z0-9_]
INT =~ [+-]?[0-9]+

Semantic stuff:
'print' is a built-in function taking any type and returning (), so printing
can be done by 'let <garbage> = print <value> in <expr>'.

Built-in types:
- String
- Int
- Bool

Some semantic checks:
- there is a main method
- within each declaration, the function names all match (we shouldn't have
    something like 'foo (A => B) is bar a b = ...;'
- No two declarations should have the same name
- Look for undefined types in function signatures and definitions
- Matching should not bind the same name more than once (we shouldn't have
    something like foo (A => A => B) is foo a a = ...;'
- Check for cyclic datatype definitions
