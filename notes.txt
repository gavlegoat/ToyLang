This is the grammar I'm using. In general capitalized words refer to nonterminal
symbols, all caps words are terminals with regular expressions, lower case words
are keywords, and symbols are literal. I use [.]+ and [.]* for lists to make
things a little simpler. Note that functions have a slightly weird syntax
because I want to make sure whitespace is unimportant. A function might look
like:

>>> foo (Int -> Int -> Bool) is
>>>     foo 0 0 = false
>>> and foo 1 1 = true
>>> and foo a b = a < b:

Also note that comments are haskell style, i.e., they may be -- to \n or they
may be {* to *}. Functions are curried so function application always occurs
between exactly two expressions and should be left associative.

Program ::= [Declaration]+

Declaration ::= Function
              | Datatype

Function ::= ID ( FunType ) is [FunDef and]* FunDef

FunType ::= [TYPE =>]* TYPE

FunDef ::= ID [PExpr]* = Expr ;

Datatype ::= data TYPE = [Constructor |]* Constructor

Constructor ::= TYPE [TYPE]*

Expr ::= ID                          -- Variable reference
       | INT                         -- Integer literal
       | STRING                      -- String literal
       | true                        -- Boolean literal true
       | false                       -- Boolean literal false
       | Expr + Expr                 -- Arithmetic Expressions
       | Expr - Expr                 --
       | Expr * Expr                 --
       | Expr / Expr                 --
       | ~ Expr                      -- Arithmetic negation
       | Expr < Expr                 -- Comparison operators
       | Expr == Expr                --
       | Expr <= Expr                --
       | Expr && Expr                -- Boolean expressions
       | Expr || Expr                --
       | not Expr                    --
       | ( Expr )                    -- Grouping
       | ( Expr , [Expr ,]* Expr )   -- Tuple construction
       | ( )                         -- Unit value
       | Expr : Expr                 -- List construction
       | [ ]                         -- Empty list
       | let ID = Expr in Expr       --
       | case Expr of [CaseBranch ;]+  --
       | if Expr then Expr else Expr --
       | Expr . Expr                 -- Function application
       | TYPE [Expr]*                -- Constructor

CaseBranch ::= PExpr -> Expr

PExpr ::= ID
        | INT
        | STRING
        | true
        | false
        | ( )
        | ( [PExpr ,]* PExpr )
        | [ ]
        | PExpr : PExpr
        | Type [PExpr]   -- Constructor matching


Regular expressions for terminals:
TYPE =~ [A-Z][A-Za-z0-9_]
ID =~ [a-z_][A-Za-z0-9_]
INT =~ [+-]?[0-9]+


Semantic stuff:
'print' is a built-in function taking any type and returning (), so printing
can be done by 'let <garbage> = print <value> in <expr>'.

Built-in types:
- String
- Int
- Bool

Some semantic checks:
- there is a main method
- within each declaration, the function names all match (we shouldn't have
    something like 'foo (A => B) is bar a b = ...;'
- No two declarations should have the same name
- Look for undefined types in function signatures and definitions
- Matching should not bind the same name more than once (we shouldn't have
    something like foo (A => A => B) is foo a a = ...;'
- Check for cyclic datatype definitions
